<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>developing/entitySystem/events · TerasologyDocs</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Events"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="developing/entitySystem/events · TerasologyDocs"/><meta property="og:type" content="website"/><meta property="og:url" content="https://kaubster.github.io/TerasologyDocs/"/><meta property="og:description" content="Events"/><meta property="og:image" content="https://kaubster.github.io/TerasologyDocs/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://kaubster.github.io/TerasologyDocs/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/TerasologyDocs/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://kaubster.github.io/TerasologyDocs/blog/atom.xml" title="TerasologyDocs Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://kaubster.github.io/TerasologyDocs/blog/feed.xml" title="TerasologyDocs Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/TerasologyDocs/js/scrollSpy.js"></script><link rel="stylesheet" href="/TerasologyDocs/css/main.css"/><script src="/TerasologyDocs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/TerasologyDocs/"><img class="logo" src="/TerasologyDocs/img/logo.png" alt="TerasologyDocs"/><h2 class="headerTitleWithLogo">TerasologyDocs</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://terasology.org" target="_self">Home</a></li><li class=""><a href="https://terasology.org/about.html" target="_self">About Us</a></li><li class=""><a href="https://terasology.org/gallery.html" target="_self">Gallery</a></li><li class=""><a href="https://forum.terasology.org/" target="_self">Forum</a></li><li class=""><a href="https://metaterasology.github.io/docs/index.html" target="_self">Docs</a></li><li class=""><a href="docs-in-iframe" target="_self">Docs (IFrame)</a></li><li class=""><a href="/TerasologyDocs/docs/doc4" target="_self">API</a></li><li class=""><a href="/TerasologyDocs/help" target="_self">Help</a></li><li class=""><a href="/TerasologyDocs/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">developing/entitySystem/events</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="events"></a><a href="#events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Events</h1>
<p>Events are sent to exactly one entity. Systems can define methods, that
get called when specific events get sent to entities with certain
components.</p>
<h2><a class="anchor" aria-hidden="true" id="defining-events"></a><a href="#defining-events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining events</h2>
<p>An event is a class that implements the interface
:java<code>Event &lt;org.terasology.entitySystem.event.Event&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</p>
<p>Its fields should be private and should be made accessible via public
getters. The event should have no setters but a constructor that takes
the values for all fields and sets them.</p>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>For events that are intend for
<code>network transfer &lt;network_events&gt;</code>{.interpreted-text role=&quot;ref&quot;}, a
public/protected default constructor has to be provided.
:::</p>
<h2><a class="anchor" aria-hidden="true" id="sending-events"></a><a href="#sending-events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sending events</h2>
<p>The recommended way of sending events is via
:java<code>EntityRef.send(Event) &lt;org.terasology.entitySystem.entity.EntityRef.send(T)&gt;</code>{.interpreted-text
role=&quot;ref&quot;}:</p>
<pre><code class="hljs css language-{.java}">entity.send(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyEvent(<span class="hljs-params">myArg1</span>, <span class="hljs-params">myArg2</span>)</span>);
</code></pre>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>By default, events aren't sent over the network. See
<code>Network Events &lt;network_events&gt;</code>{.interpreted-text role=&quot;ref&quot;} for
further options to send events over the network.
:::</p>
<h2><a class="anchor" aria-hidden="true" id="processing-events-eventssystems_processingevents"></a><a href="#processing-events-eventssystems_processingevents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Processing events {#eventsSystems_processingEvents}</h2>
<p>To make a class a system you annotate it with the
:java<code>@RegisterSystem &lt;org.terasology.entitySystem.systems.RegisterSystem&gt;</code>{.interpreted-text
role=&quot;ref&quot;} annotation. If a system implements certain engine interfaces
like
:java<code>UpdateSubscriberSystem &lt;org.terasology.entitySystem.systems.UpdateSubscriberSystem&gt;</code>{.interpreted-text
role=&quot;ref&quot;}, then the methods of that interface will automatically be
called by the engine. In addition to that, systems can declare methods
that get called when certain events occurred at certain entities.</p>
<p>Event processing methods must have the following method signature:</p>
<ul>
<li>They must have a
:java<code>@ReceiveEvent &lt;org.terasology.entitySystem.event.ReceiveEvent&gt;</code>{.interpreted-text
role=&quot;ref&quot;} annotation.</li>
<li>They must be public.</li>
<li>The type of the first argument must implement
:java<code>Event &lt;org.terasology.entitySystem.event.Event&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</li>
<li>The second argument must be of type
:java<code>EntityRef &lt;org.terasology.entitySystem.entity.EntityRef&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</li>
<li>The rest of the arguments if there are some must implement
:java<code>Component &lt;org.terasology.entitySystem.Component&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</li>
</ul>
<p>Example:</p>
<pre><code class="hljs css language-{.java}">@<span class="hljs-type">ReceiveEvent</span>(components = {<span class="hljs-type">MyComponent</span>.class, <span class="hljs-type">LocationComponent</span>.class})
public <span class="hljs-built_in">void</span> onMyComponentAdded(<span class="hljs-type">OnAddedComponent</span> event, <span class="hljs-type">EntityRef</span> entity, <span class="hljs-type">MyComponent</span> myComponent) <span class="hljs-meta">{...}</span>
</code></pre>
<p>The method gets called, when the <code>OnAddedComponent</code> event occurs at an
entity, which has all of the following components: <code>MyComponent</code>,
<code>LocationComponent</code>.</p>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>The listing of a component in the annotation and the method seems to be
redundant, but allows direct access to the component.</p>
<p><strong>Parameter Access</strong></p>
<pre><code class="hljs css language-{.java}">@<span class="hljs-constructor">ReceiveEvent(<span class="hljs-params">components</span> = {MyComponent.<span class="hljs-params">class</span>, LocationComponent.<span class="hljs-params">class</span>})</span>
public void on<span class="hljs-constructor">MyComponentAdded(OnAddedComponent <span class="hljs-params">event</span>, EntityRef <span class="hljs-params">entity</span>, MyComponent <span class="hljs-params">myComponent</span>)</span> {
    myComponent.change<span class="hljs-constructor">SomeValues()</span>;
    entity.save<span class="hljs-constructor">Component(<span class="hljs-params">myComponent</span>)</span>;
}
</code></pre>
<p><strong>Direct Access</strong></p>
<pre><code class="hljs css language-{.java}">@<span class="hljs-constructor">ReceiveEvent(<span class="hljs-params">components</span> = {MyComponent.<span class="hljs-params">class</span>, LocationComponent.<span class="hljs-params">class</span>})</span>
public void on<span class="hljs-constructor">MyComponentAdded(OnAddedComponent <span class="hljs-params">event</span>, EntityRef <span class="hljs-params">entity</span>)</span> {
    MyComponent myComponent = entity.get<span class="hljs-constructor">Component(MyComponent.<span class="hljs-params">class</span>)</span>;
    myComponent.change<span class="hljs-constructor">SomeValues()</span>;
    entity.save<span class="hljs-constructor">Component(<span class="hljs-params">myComponent</span>)</span>;
}
</code></pre>
<p>Which style to use depends on personal preference and readability. For a
large amount of components, the direct access inside the method should
be preferred.
:::</p>
<p>The method signature determines when the method will be called:</p>
<ol>
<li>The first argument controls the type of the event. This will also
include sub-classes, e.g. for
:java<code>NetworkEvent &lt;org.terasology.network.NetworkEvent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</li>
<li>The method will only be called if the entity has all components
specified in the
:java<code>@ReceiveEvent &lt;org.terasology.entitySystem.event.ReceiveEvent&gt;</code>{.interpreted-text
role=&quot;ref&quot;} annotation.</li>
<li>The method will only be called if the entity has all components
specified in the optional method parameters. Even if these
components are not included in the annotation.</li>
<li>The call order for multiple event listeners is set via a priority
flag in the annotation:
<code>@ReceiveEvent(priority=EventPriority.PRIORITY_NORMAL)</code>. Internally,
this is an int value but should always be one constant of
:java<code>EventPriority &lt;org.terasology.entitySystem.event.EventPriority&gt;</code>{.interpreted-text
role=&quot;ref&quot;}.</li>
<li>It is possible to restrict event handlers to be processed only on
the client, the server or both:
<code>@ReceiveEvent(netFilter=RegisterMode.ALWAYS)</code>. The
:java<code>RegisterMode &lt;org.terasology.entitySystem.systems.RegisterMode&gt;</code>{.interpreted-text
role=&quot;ref&quot;} determines when the handler will be registered. This is
barely needed, as the same flag can be set globally for the entire
class, using the same parameter in the
:java<code>@RegisterSystem &lt;org.terasology.entitySystem.systems.RegisterSystem&gt;</code>{.interpreted-text
role=&quot;ref&quot;} annotation.</li>
</ol>
<p>::: {.note}
::: {.title}
Note
:::</p>
<p>Some events like the
:java<code>OnAddedComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.OnAddedComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;} event are implicitly linked to a component and will only be
offered to methods that require those arguments. In the upper case the
event fires only when <code>LocationComponent</code> got added while <code>MyComponent</code>
was present or when <code>MyComponent</code> got added while <code>LocationComponent</code>
was present. When another component gets added, while <code>MyComponent</code> and
<code>LocationComponent</code> are present, the method won't be called.</p>
<p>This is the case for the following lifecycle core events, which are
linked to to a component and require handling methods to list them
explicitely:</p>
<ul>
<li>:java<code>OnAddedComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.OnAddedComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}</li>
<li>:java<code>OnActivatedComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.OnActivatedComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}</li>
<li>:java<code>OnChangedComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.OnChangedComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}</li>
<li>:java<code>BeforeDeactivateComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.BeforeDeactivateComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}</li>
<li>:java<code>BeforeRemoveComponent &lt;org.terasology.entitySystem.entity.lifecycleEvents.BeforeRemoveComponent&gt;</code>{.interpreted-text
role=&quot;ref&quot;}</li>
</ul>
<p>All other core events and probably all module events aren't linked to a
component. Please read the Javadoc of any event you make a system for.
:::</p>
<h2><a class="anchor" aria-hidden="true" id="consumable-events"></a><a href="#consumable-events" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consumable events</h2>
<p>Normally an event is processed by the event handling methods in the
order of their priority. Events that implement
:java<code>ConsumableEvent &lt;org.terasology.entitySystem.event.ConsumableEvent&gt;</code>{.interpreted-text
role=&quot;ref&quot;} can, however, be consumed. Once an event is consumed its
event handling stops and the remaining event handlers (with lower
priority) do not see the event.</p>
<p>One example usage is to determine what happens with user input: When the
player is in a mine cart, the input movement events may be consumed by a
high priority mine cart event handler before they reach the normal
movement handlers to avoid the player walking out of the cart.</p>
<p>The sender of consumable events can check if their event got consumed.
Some consumable events are sent as a test to figure out if there is a
new system that objects with the action being taken. For example the
event
:java<code>BeforeItemPutInInventory &lt;org.terasology.logic.inventory.events.BeforeItemPutInInventory&gt;</code>{.interpreted-text
role=&quot;ref&quot;} can be consumed by a new system, to prevent the placement of
items in a slot that is reserved for certain other items.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-events">Defining events</a></li><li><a href="#sending-events">Sending events</a></li><li><a href="#processing-events-eventssystems_processingevents">Processing events {#eventsSystems_processingEvents}</a></li><li><a href="#consumable-events">Consumable events</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/TerasologyDocs/" class="nav-home"><img src="/TerasologyDocs/img/favicon.ico" alt="TerasologyDocs" width="66" height="58"/></a><div><h5>Docs</h5><a href="/TerasologyDocs/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/TerasologyDocs/docs/en/doc2.html">Guides (or other categories)</a><a href="/TerasologyDocs/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/TerasologyDocs/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/TerasologyDocs/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/TerasologyDocs/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Licensed under Apache 2.0</section></footer></div></body></html>